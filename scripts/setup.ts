/**
 * HubbleWave Platform Setup Script
 *
 * One-command setup for development environment.
 * Handles: env files, Docker services, and database initialization.
 *
 * Usage:
 *   npx ts-node scripts/setup.ts
 *   npm run setup
 */

import { execSync, spawn } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import * as readline from 'readline';

const ROOT_DIR = path.resolve(__dirname, '..');

interface SetupOptions {
  skipDocker?: boolean;
  skipEnv?: boolean;
}

function log(message: string, type: 'info' | 'success' | 'warn' | 'error' = 'info') {
  const colors = {
    info: '\x1b[36m',    // Cyan
    success: '\x1b[32m', // Green
    warn: '\x1b[33m',    // Yellow
    error: '\x1b[31m',   // Red
  };
  const reset = '\x1b[0m';
  const prefix = {
    info: '[INFO]',
    success: '[OK]',
    warn: '[WARN]',
    error: '[ERROR]',
  };
  console.log(`${colors[type]}${prefix[type]}${reset} ${message}`);
}

function generateSecret(bytes: number = 64): string {
  return crypto.randomBytes(bytes).toString('hex');
}

async function setupEnvFiles(): Promise<void> {
  log('Setting up environment files...');

  const envPath = path.join(ROOT_DIR, '.env');
  const envExamplePath = path.join(ROOT_DIR, '.env.example');

  if (fs.existsSync(envPath)) {
    log('.env file already exists, skipping', 'warn');
    return;
  }

  if (!fs.existsSync(envExamplePath)) {
    log('.env.example not found, creating default .env', 'warn');
  }

  // Generate secure secrets
  const jwtSecret = generateSecret(64);
  const encryptionKey = generateSecret(32);

  const envContent = `# HubbleWave Platform Environment Configuration
# Generated by setup script on ${new Date().toISOString()}

# JWT Configuration (auto-generated secure values)
JWT_SECRET=${jwtSecret}
JWT_EXPIRES_IN=15m
JWT_REFRESH_EXPIRES_IN=7d

# Encryption Key for MFA secrets
ENCRYPTION_KEY=${encryptionKey}

# Database Configuration
DB_HOST=localhost
DB_PORT=5432
POSTGRES_USER=hubblewave
POSTGRES_PASSWORD=hubblewave
POSTGRES_DB=hubblewave

# Service Ports
PORT_IDENTITY=3000
PORT_METADATA=3002
PORT_DATA=3001

# Redis Configuration
REDIS_HOST=localhost
REDIS_PORT=6379

# MinIO Configuration
MINIO_ROOT_USER=admin
MINIO_ROOT_PASSWORD=password
MINIO_ENDPOINT=localhost
MINIO_PORT=9000

# TypeSense Configuration
TYPESENSE_HOST=localhost
TYPESENSE_PORT=8108
TYPESENSE_API_KEY=xyz123

# CORS Configuration
CORS_ORIGINS=http://localhost:4200,http://localhost:5173,http://127.0.0.1:4200,http://127.0.0.1:5173
CORS_ALLOWED_HEADERS=Content-Type, Authorization, X-Requested-With, Accept, Origin



# Refresh token cookies
USE_REFRESH_TOKEN_COOKIE=true
REFRESH_COOKIE_SAMESITE=lax
REFRESH_COOKIE_PATH=/
REFRESH_COOKIE_SECURE=false

# Account lockout settings
MAX_FAILED_LOGIN_ATTEMPTS=5
ACCOUNT_LOCKOUT_DURATION_MINUTES=30

# Node Environment
NODE_ENV=development

# AI / LLM Configuration
VLLM_BASE_URL=http://localhost:11434/v1
VLLM_DEFAULT_MODEL=llama3
VLLM_EMBEDDING_MODEL=nomic-embed-text
`;

  fs.writeFileSync(envPath, envContent);
  log('.env file created with secure secrets', 'success');
}

async function checkDockerRunning(): Promise<boolean> {
  try {
    execSync('docker info', { stdio: 'pipe' });
    return true;
  } catch {
    return false;
  }
}

async function startDockerServices(): Promise<void> {
  log('Starting Docker services...');

  if (!await checkDockerRunning()) {
    log('Docker is not running. Please start Docker Desktop and run setup again.', 'error');
    process.exit(1);
  }

  try {
    // Start services in detached mode
    execSync('docker-compose up -d', {
      cwd: ROOT_DIR,
      stdio: 'inherit',
    });
    log('Docker services started', 'success');
  } catch (error) {
    log(`Failed to start Docker services: ${error}`, 'error');
    process.exit(1);
  }
}

async function waitForPostgres(maxAttempts: number = 30): Promise<void> {
  log('Waiting for PostgreSQL to be ready...');

  for (let i = 0; i < maxAttempts; i++) {
    try {
      execSync(
        'docker exec hw_postgres pg_isready -U hubblewave -d hubblewave',
        { stdio: 'pipe' }
      );
      log('PostgreSQL is ready', 'success');
      return;
    } catch {
      process.stdout.write('.');
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }

  log('PostgreSQL did not become ready in time', 'error');
  process.exit(1);
}

async function waitForRedis(maxAttempts: number = 30): Promise<void> {
  log('Waiting for Redis to be ready...');

  for (let i = 0; i < maxAttempts; i++) {
    try {
      execSync('docker exec hw_redis redis-cli ping', { stdio: 'pipe' });
      log('Redis is ready', 'success');
      return;
    } catch {
      process.stdout.write('.');
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }

  log('Redis did not become ready in time', 'error');
  process.exit(1);
}

async function runMigrations(): Promise<void> {
  log('Running database migrations...');

  try {
    // Run instance migrations (SINGLE INSTANCE ARCHITECTURE)
    execSync('npm run migration:run:instance', {
      cwd: ROOT_DIR,
      stdio: 'inherit',
    });
    log('Instance migrations completed', 'success');
  } catch (error) {
    log(`Migration failed: ${error}`, 'error');
    process.exit(1);
  }
}

async function seedAdminUser(): Promise<void> {
  log('Seeding admin user...');

  try {
    execSync('npx ts-node scripts/seed-admin-user.ts', {
      cwd: ROOT_DIR,
      stdio: 'inherit',
    });
    log('Admin user seeded', 'success');
  } catch (error) {
    log(`Failed to seed admin user: ${error}`, 'warn');
  }
}

async function installDependencies(): Promise<void> {
  log('Installing npm dependencies...');

  try {
    execSync('npm install', {
      cwd: ROOT_DIR,
      stdio: 'inherit',
    });
    log('Dependencies installed', 'success');
  } catch (error) {
    log(`Failed to install dependencies: ${error}`, 'error');
    process.exit(1);
  }
}

async function printSummary(): Promise<void> {
  console.log('\n' + '='.repeat(60));
  console.log('\x1b[32m Setup Complete! \x1b[0m');
  console.log('='.repeat(60));
  console.log(`
Services running:
  - PostgreSQL:  localhost:5432
  - Redis:       localhost:6379
  - MinIO:       localhost:9000 (Console: localhost:9001)
  - TypeSense:   localhost:8108

Default credentials:
  - Database:    hubblewave / hubblewave
  - MinIO:       admin / password
  - TypeSense:   API Key: xyz123

Next steps:
  1. Start the backend services:
     npm run dev:all

  2. Or start services individually:
     npm run dev:identity   # Identity service (port 3000)
     npm run dev:metadata   # Metadata service (port 3002)
     npm run dev:data       # Data service (port 3001)
     npm run dev:web        # Web client (port 4200)

  3. Access the application:
     http://localhost:4200

  4. Login with:
     Email:    adityasingampally@hubblewave.com
     Password: password123
`);
  console.log('='.repeat(60) + '\n');
}

async function main(): Promise<void> {
  console.log('\n============================================================');
  console.log('  HubbleWave Platform Development Setup (Single Instance)');
  console.log('============================================================\n');

  const args = process.argv.slice(2);
  const options: SetupOptions = {
    skipDocker: args.includes('--skip-docker'),
    skipEnv: args.includes('--skip-env'),
  };

  try {
    // Step 1: Install dependencies
    await installDependencies();

    // Step 2: Setup environment files
    if (!options.skipEnv) {
      await setupEnvFiles();
    }

    // Step 3: Start Docker services
    if (!options.skipDocker) {
      await startDockerServices();
      await waitForPostgres();
      await waitForRedis();
    }

    // Step 4: Run migrations
    await runMigrations();

    // Step 5: Seed Admin user
    await seedAdminUser();

    // Print summary
    await printSummary();

  } catch (error) {
    log(`Setup failed: ${error}`, 'error');
    process.exit(1);
  }
}

main();

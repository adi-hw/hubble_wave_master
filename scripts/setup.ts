/**
 * HubbleWave Platform Setup Script
 *
 * One-command setup for development environment.
 * Handles: env files, Docker services, and database initialization.
 *
 * Usage:
 *   npx ts-node scripts/setup.ts
 *   npm run setup
 */

import { execSync } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import * as http from 'http';
import * as https from 'https';
import * as dotenv from 'dotenv';

const ROOT_DIR = path.resolve(__dirname, '..');

interface SetupOptions {
  skipDocker?: boolean;
  skipEnv?: boolean;
}

function log(message: string, type: 'info' | 'success' | 'warn' | 'error' = 'info') {
  const colors = {
    info: '\x1b[36m',    // Cyan
    success: '\x1b[32m', // Green
    warn: '\x1b[33m',    // Yellow
    error: '\x1b[31m',   // Red
  };
  const reset = '\x1b[0m';
  const prefix = {
    info: '[INFO]',
    success: '[OK]',
    warn: '[WARN]',
    error: '[ERROR]',
  };
  console.log(`${colors[type]}${prefix[type]}${reset} ${message}`);
}

function generateSecret(bytes: number = 64): string {
  return crypto.randomBytes(bytes).toString('hex');
}

async function setupEnvFiles(): Promise<void> {
  log('Setting up environment files...');

  const envPath = path.join(ROOT_DIR, '.env');
  const envExamplePath = path.join(ROOT_DIR, '.env.example');

  if (fs.existsSync(envPath)) {
    dotenv.config({ path: envPath, override: false });
    log('.env file already exists, loaded configuration', 'warn');
    return;
  }

  if (!fs.existsSync(envExamplePath)) {
    log('.env.example not found, creating default .env', 'warn');
  }

  const jwtSecret = generateSecret(64);
  const encryptionKey = generateSecret(32);
  const dbPassword = generateSecret(24);
  const minioPassword = generateSecret(24);
  const typesenseApiKey = generateSecret(24);
  const adminPassword = generateSecret(24);
  const adminEmail = 'admin@hubblewave.local';
  const adminFirstName = 'HubbleWave';
  const adminLastName = 'Admin';
  const adminDisplayName = `${adminFirstName} ${adminLastName}`;

  const envContent = `# HubbleWave Platform Environment Configuration
# Generated by setup script on ${new Date().toISOString()}

# JWT Configuration (auto-generated secure values)
JWT_SECRET=${jwtSecret}
JWT_EXPIRES_IN=15m
JWT_REFRESH_EXPIRES_IN=7d

# Encryption Key for MFA secrets
ENCRYPTION_KEY=${encryptionKey}

# Database Configuration
DB_HOST=localhost
DB_PORT=5432
DB_USER=hubblewave
DB_PASSWORD=${dbPassword}
DB_NAME=hubblewave

# Control Plane Database
CONTROL_PLANE_DB_HOST=localhost
CONTROL_PLANE_DB_PORT=5432
CONTROL_PLANE_DB_USER=hubblewave
CONTROL_PLANE_DB_PASSWORD=${dbPassword}
CONTROL_PLANE_DB_NAME=hubblewave_control_plane

# Postgres Container Defaults
POSTGRES_USER=hubblewave
POSTGRES_PASSWORD=${dbPassword}
POSTGRES_DB=hubblewave

# Service Ports
PORT_IDENTITY=3000
PORT_DATA=3002
PORT_METADATA=3003
PORT_AVA=3004
PORT_AUTOMATION=3005
PORT_VIEW_ENGINE=3006
PORT_INSIGHTS=3007

# Admin Bootstrap
ADMIN_EMAIL=${adminEmail}
ADMIN_PASSWORD=${adminPassword}
ADMIN_FIRST_NAME=${adminFirstName}
ADMIN_LAST_NAME=${adminLastName}
ADMIN_DISPLAY_NAME=${adminDisplayName}

# Redis Configuration
REDIS_HOST=localhost
REDIS_PORT=6379

# Storage Configuration (MinIO)
STORAGE_PROVIDER=minio
MINIO_ROOT_USER=admin
MINIO_ROOT_PASSWORD=${minioPassword}
MINIO_ENDPOINT=localhost
MINIO_PORT=9000
MINIO_USE_SSL=false
MINIO_BUCKET_ATTACHMENTS=hw-instance-attachments
MINIO_BUCKET_PACK_ARTIFACTS=hw-pack-artifacts
MINIO_BUCKET_MODEL_VAULT=hw-model-vault

# TypeSense Configuration
TYPESENSE_HOST=localhost
TYPESENSE_PORT=8108
TYPESENSE_PROTOCOL=http
TYPESENSE_API_KEY=${typesenseApiKey}

# CORS Configuration
CORS_ORIGINS=http://localhost:4200,http://localhost:5173,http://127.0.0.1:4200,http://127.0.0.1:5173
CORS_ALLOWED_HEADERS=Content-Type, Authorization, X-Requested-With, Accept, Origin

# Refresh token cookies
USE_REFRESH_TOKEN_COOKIE=true
REFRESH_COOKIE_SAMESITE=lax
REFRESH_COOKIE_PATH=/
REFRESH_COOKIE_SECURE=false

# Account lockout settings
MAX_FAILED_LOGIN_ATTEMPTS=5
ACCOUNT_LOCKOUT_DURATION_MINUTES=30

# Node Environment
NODE_ENV=development

# AVA Runtime Configuration
VLLM_BASE_URL=http://localhost:11434
VLLM_DEFAULT_MODEL=llama3:latest
VLLM_EMBEDDING_MODEL=nomic-embed-text
`;

  fs.writeFileSync(envPath, envContent);
  dotenv.config({ path: envPath, override: true });
  log('.env file created with secure secrets', 'success');
}

async function checkDockerRunning(): Promise<boolean> {
  try {
    execSync('docker info', { stdio: 'pipe' });
    return true;
  } catch {
    return false;
  }
}

async function startDockerServices(): Promise<void> {
  log('Starting Docker services...');

  if (!await checkDockerRunning()) {
    log('Docker is not running. Please start Docker Desktop and run setup again.', 'error');
    process.exit(1);
  }

  try {
    // Start services in detached mode
    execSync('docker-compose up -d', {
      cwd: ROOT_DIR,
      stdio: 'inherit',
    });
    log('Docker services started', 'success');
  } catch (error) {
    log(`Failed to start Docker services: ${error}`, 'error');
    process.exit(1);
  }
}

async function waitForPostgres(maxAttempts: number = 30): Promise<void> {
  log('Waiting for PostgreSQL to be ready...');

  for (let i = 0; i < maxAttempts; i++) {
    try {
      const dbUser = process.env.DB_USER || 'hubblewave';
      const dbName = process.env.DB_NAME || 'hubblewave';
      execSync(`docker exec hw_postgres pg_isready -U ${dbUser} -d ${dbName}`, {
        stdio: 'pipe',
      });
      log('PostgreSQL is ready', 'success');
      return;
    } catch {
      process.stdout.write('.');
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }

  log('PostgreSQL did not become ready in time', 'error');
  process.exit(1);
}

async function waitForRedis(maxAttempts: number = 30): Promise<void> {
  log('Waiting for Redis to be ready...');

  for (let i = 0; i < maxAttempts; i++) {
    try {
      execSync('docker exec hw_redis redis-cli ping', { stdio: 'pipe' });
      log('Redis is ready', 'success');
      return;
    } catch {
      process.stdout.write('.');
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }

  log('Redis did not become ready in time', 'error');
  process.exit(1);
}

function requestStatus(url: string): Promise<number> {
  return new Promise((resolve, reject) => {
    const client = url.startsWith('https') ? https : http;
    const request = client.get(url, (response) => {
      response.resume();
      resolve(response.statusCode ?? 0);
    });
    request.on('error', reject);
    request.setTimeout(2000, () => {
      request.destroy(new Error('Request timed out'));
    });
  });
}

async function waitForHttpService(
  name: string,
  url: string,
  maxAttempts: number = 30
): Promise<void> {
  log(`Waiting for ${name} to be ready...`);

  for (let i = 0; i < maxAttempts; i++) {
    try {
      const status = await requestStatus(url);
      if (status >= 200 && status < 300) {
        log(`${name} is ready`, 'success');
        return;
      }
    } catch {
      process.stdout.write('.');
    }
    await new Promise((resolve) => setTimeout(resolve, 1000));
  }

  log(`${name} did not become ready in time`, 'error');
  process.exit(1);
}

async function runMigrations(): Promise<void> {
  log('Running database migrations...');

  try {
    execSync('npm run migration:run:control-plane', {
      cwd: ROOT_DIR,
      stdio: 'inherit',
    });
    log('Control Plane migrations completed', 'success');

    execSync('npm run migration:run:instance', {
      cwd: ROOT_DIR,
      stdio: 'inherit',
    });
    log('Instance migrations completed', 'success');
  } catch (error) {
    log(`Migration failed: ${error}`, 'error');
    process.exit(1);
  }
}

async function seedAdminUser(): Promise<void> {
  log('Seeding admin user...');

  try {
    execSync('npx ts-node scripts/seed-admin-user.ts', {
      cwd: ROOT_DIR,
      stdio: 'inherit',
    });
    log('Admin user seeded', 'success');
  } catch (error) {
    log(`Failed to seed admin user: ${error}`, 'warn');
  }
}

async function bootstrapBuckets(): Promise<void> {
  log('Bootstrapping storage buckets...');

  try {
    execSync('npx ts-node scripts/bootstrap-buckets.ts', {
      cwd: ROOT_DIR,
      stdio: 'inherit',
    });
    log('Buckets bootstrapped', 'success');
  } catch (error) {
    log(`Bucket bootstrap failed: ${error}`, 'error');
    process.exit(1);
  }
}

async function bootstrapTypesense(): Promise<void> {
  log('Bootstrapping TypeSense...');

  try {
    execSync('npx ts-node scripts/bootstrap-typesense.ts', {
      cwd: ROOT_DIR,
      stdio: 'inherit',
    });
    log('TypeSense bootstrapped', 'success');
  } catch (error) {
    log(`TypeSense bootstrap failed: ${error}`, 'error');
    process.exit(1);
  }
}

async function seedPlatformKnowledge(): Promise<void> {
  log('Seeding platform knowledge...');

  try {
    execSync('npx ts-node scripts/seed-platform-knowledge.ts', {
      cwd: ROOT_DIR,
      stdio: 'inherit',
    });
    log('Platform knowledge seeded', 'success');
  } catch (error) {
    log(`Platform knowledge seed failed: ${error}`, 'error');
    process.exit(1);
  }
}

async function installDependencies(): Promise<void> {
  log('Installing npm dependencies...');

  try {
    execSync('npm install', {
      cwd: ROOT_DIR,
      stdio: 'inherit',
    });
    log('Dependencies installed', 'success');
  } catch (error) {
    log(`Failed to install dependencies: ${error}`, 'error');
    process.exit(1);
  }
}

async function printSummary(): Promise<void> {
  console.log('\n' + '='.repeat(60));
  console.log('\x1b[32m Setup Complete! \x1b[0m');
  console.log('='.repeat(60));
  console.log(`
Services running:
  - PostgreSQL:  localhost:5432
  - Redis:       localhost:6379
  - MinIO:       localhost:9000 (Console: localhost:9001)
  - TypeSense:   localhost:8108
  - AVA Runtime: localhost:11434

Credentials:
  - Admin, database, storage, and TypeSense credentials are stored in .env

Next steps:
  1. Start the backend services:
     npm run dev:all

  2. Or start services individually:
     npm run dev:identity   # Identity service (port 3000)
     npm run dev:data       # Data service (port 3002)
     npm run dev:metadata   # Metadata service (port 3003)
     npm run dev:web        # Web client (port 4200)

  3. Access the application:
     http://localhost:4200
`);
  console.log('='.repeat(60) + '\n');
}

async function main(): Promise<void> {
  console.log('\n============================================================');
  console.log('  HubbleWave Platform Development Setup (Single Instance)');
  console.log('============================================================\n');

  const args = process.argv.slice(2);
  const options: SetupOptions = {
    skipDocker: args.includes('--skip-docker'),
    skipEnv: args.includes('--skip-env'),
  };

  try {
    await installDependencies();

    if (!options.skipEnv) {
      await setupEnvFiles();
    } else {
      const envPath = path.join(ROOT_DIR, '.env');
      if (fs.existsSync(envPath)) {
        dotenv.config({ path: envPath, override: false });
      }
    }

    if (!options.skipDocker) {
      await startDockerServices();
    }

    await waitForPostgres();
    await waitForRedis();
    await waitForHttpService('MinIO', 'http://localhost:9000/minio/health/live');
    await waitForHttpService('TypeSense', 'http://localhost:8108/health');
    await waitForHttpService('AVA Runtime', 'http://localhost:11434/api/tags', 90);

    await runMigrations();

    await bootstrapBuckets();
    await bootstrapTypesense();

    await seedAdminUser();

    await seedPlatformKnowledge();

    await printSummary();

  } catch (error) {
    log(`Setup failed: ${error}`, 'error');
    process.exit(1);
  }
}

main();

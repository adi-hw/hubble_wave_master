#!/usr/bin/env npx ts-node
/**
 * EAM Platform Setup Script
 *
 * One-command setup for development environment.
 * Handles: env files, Docker services, database initialization, and tenant provisioning.
 *
 * Usage:
 *   npx ts-node scripts/setup.ts
 *   npm run setup
 */

import { execSync, spawn } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';
import * as readline from 'readline';

const ROOT_DIR = path.resolve(__dirname, '..');

interface SetupOptions {
  skipDocker?: boolean;
  skipEnv?: boolean;
  skipTenant?: boolean;
  tenantSlug?: string;
  tenantName?: string;
}

function log(message: string, type: 'info' | 'success' | 'warn' | 'error' = 'info') {
  const colors = {
    info: '\x1b[36m',    // Cyan
    success: '\x1b[32m', // Green
    warn: '\x1b[33m',    // Yellow
    error: '\x1b[31m',   // Red
  };
  const reset = '\x1b[0m';
  const prefix = {
    info: '[INFO]',
    success: '[OK]',
    warn: '[WARN]',
    error: '[ERROR]',
  };
  console.log(`${colors[type]}${prefix[type]}${reset} ${message}`);
}

function generateSecret(bytes: number = 64): string {
  return crypto.randomBytes(bytes).toString('hex');
}

async function setupEnvFiles(): Promise<void> {
  log('Setting up environment files...');

  const envPath = path.join(ROOT_DIR, '.env');
  const envExamplePath = path.join(ROOT_DIR, '.env.example');

  if (fs.existsSync(envPath)) {
    log('.env file already exists, skipping', 'warn');
    return;
  }

  if (!fs.existsSync(envExamplePath)) {
    log('.env.example not found, creating default .env', 'warn');
  }

  // Generate secure secrets
  const jwtSecret = generateSecret(64);
  const encryptionKey = generateSecret(32);

  const envContent = `# EAM Platform Environment Configuration
# Generated by setup script on ${new Date().toISOString()}

# JWT Configuration (auto-generated secure values)
JWT_SECRET=${jwtSecret}
JWT_EXPIRES_IN=15m
JWT_REFRESH_EXPIRES_IN=7d

# Encryption Key for MFA secrets
ENCRYPTION_KEY=${encryptionKey}

# Database Configuration
DB_HOST=localhost
DB_PORT=5432
POSTGRES_USER=admin
POSTGRES_PASSWORD=password
POSTGRES_DB=eam_global

# Service Ports
PORT_IDENTITY=3000
PORT_METADATA=3002
PORT_DATA=3001

# Redis Configuration
REDIS_HOST=localhost
REDIS_PORT=6379

# MinIO Configuration
MINIO_ROOT_USER=admin
MINIO_ROOT_PASSWORD=password
MINIO_ENDPOINT=localhost
MINIO_PORT=9000

# TypeSense Configuration
TYPESENSE_HOST=localhost
TYPESENSE_PORT=8108
TYPESENSE_API_KEY=xyz123

# CORS Configuration
CORS_ORIGINS=http://localhost:4200,http://localhost:5173,http://127.0.0.1:4200,http://127.0.0.1:5173
CORS_ALLOWED_HEADERS=Content-Type, Authorization, X-Requested-With, Accept, Origin, X-Tenant-Slug

# Tenancy defaults
DEFAULT_TENANT_SLUG=acme
ALLOW_DEFAULT_TENANT_FALLBACK=true

# Refresh token cookies
USE_REFRESH_TOKEN_COOKIE=true
REFRESH_COOKIE_SAMESITE=lax
REFRESH_COOKIE_PATH=/
REFRESH_COOKIE_SECURE=false

# Account lockout settings
MAX_FAILED_LOGIN_ATTEMPTS=5
ACCOUNT_LOCKOUT_DURATION_MINUTES=30

# Node Environment
NODE_ENV=development
`;

  fs.writeFileSync(envPath, envContent);
  log('.env file created with secure secrets', 'success');
}

async function checkDockerRunning(): Promise<boolean> {
  try {
    execSync('docker info', { stdio: 'pipe' });
    return true;
  } catch {
    return false;
  }
}

async function startDockerServices(): Promise<void> {
  log('Starting Docker services...');

  if (!await checkDockerRunning()) {
    log('Docker is not running. Please start Docker Desktop and run setup again.', 'error');
    process.exit(1);
  }

  try {
    // Start services in detached mode
    execSync('docker-compose up -d', {
      cwd: ROOT_DIR,
      stdio: 'inherit',
    });
    log('Docker services started', 'success');
  } catch (error) {
    log(`Failed to start Docker services: ${error}`, 'error');
    process.exit(1);
  }
}

async function waitForPostgres(maxAttempts: number = 30): Promise<void> {
  log('Waiting for PostgreSQL to be ready...');

  for (let i = 0; i < maxAttempts; i++) {
    try {
      execSync(
        'docker exec eam_postgres pg_isready -U admin -d eam_global',
        { stdio: 'pipe' }
      );
      log('PostgreSQL is ready', 'success');
      return;
    } catch {
      process.stdout.write('.');
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }

  log('PostgreSQL did not become ready in time', 'error');
  process.exit(1);
}

async function waitForRedis(maxAttempts: number = 30): Promise<void> {
  log('Waiting for Redis to be ready...');

  for (let i = 0; i < maxAttempts; i++) {
    try {
      execSync('docker exec eam_redis redis-cli ping', { stdio: 'pipe' });
      log('Redis is ready', 'success');
      return;
    } catch {
      process.stdout.write('.');
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }

  log('Redis did not become ready in time', 'error');
  process.exit(1);
}

async function runMigrations(): Promise<void> {
  log('Running database migrations...');

  try {
    // Run platform migrations
    execSync('npm run migration:run:platform', {
      cwd: ROOT_DIR,
      stdio: 'inherit',
    });
    log('Platform migrations completed', 'success');
  } catch (error) {
    log(`Migration warning: ${error}`, 'warn');
    log('Migrations may not be set up yet - continuing...', 'info');
  }
}

async function provisionDefaultTenant(slug: string, name: string): Promise<void> {
  log(`Provisioning default tenant: ${name} (${slug})...`);

  try {
    execSync(`npx ts-node scripts/provision-tenant.ts ${slug} "${name}"`, {
      cwd: ROOT_DIR,
      stdio: 'inherit',
    });
    log(`Tenant "${slug}" provisioned`, 'success');
  } catch (error) {
    log(`Failed to provision tenant: ${error}`, 'error');
    process.exit(1);
  }
}

async function seedTestUser(): Promise<void> {
  log('Seeding test user...');

  try {
    execSync('npx ts-node scripts/seed-test-user.ts', {
      cwd: ROOT_DIR,
      stdio: 'inherit',
    });
    log('Test user seeded', 'success');
  } catch (error) {
    log(`Failed to seed test user: ${error}`, 'warn');
    log('You may need to create users manually', 'info');
  }
}

async function installDependencies(): Promise<void> {
  log('Installing npm dependencies...');

  try {
    execSync('npm install', {
      cwd: ROOT_DIR,
      stdio: 'inherit',
    });
    log('Dependencies installed', 'success');
  } catch (error) {
    log(`Failed to install dependencies: ${error}`, 'error');
    process.exit(1);
  }
}

async function printSummary(): Promise<void> {
  console.log('\n' + '='.repeat(60));
  console.log('\x1b[32m Setup Complete! \x1b[0m');
  console.log('='.repeat(60));
  console.log(`
Services running:
  - PostgreSQL:  localhost:5432
  - Redis:       localhost:6379
  - MinIO:       localhost:9000 (Console: localhost:9001)
  - TypeSense:   localhost:8108

Default credentials:
  - Database:    admin / password
  - MinIO:       admin / password
  - TypeSense:   API Key: xyz123

Next steps:
  1. Start the backend services:
     npm run dev:all

  2. Or start services individually:
     npm run dev:identity   # Identity service (port 3000)
     npm run dev:metadata   # Metadata service (port 3002)
     npm run dev:data       # Data service (port 3001)
     npm run dev:web        # Web client (port 4200)

  3. Access the application:
     http://localhost:4200

  4. Default test user (if seeded):
     Username: admin
     Password: admin123
`);
  console.log('='.repeat(60) + '\n');
}

async function main(): Promise<void> {
  console.log('\n' + '='.repeat(60));
  console.log('  EAM Platform Development Setup');
  console.log('='.repeat(60) + '\n');

  const args = process.argv.slice(2);
  const options: SetupOptions = {
    skipDocker: args.includes('--skip-docker'),
    skipEnv: args.includes('--skip-env'),
    skipTenant: args.includes('--skip-tenant'),
    tenantSlug: 'acme',
    tenantName: 'Acme Corporation',
  };

  // Parse tenant options
  const slugIndex = args.indexOf('--tenant');
  if (slugIndex !== -1 && args[slugIndex + 1]) {
    options.tenantSlug = args[slugIndex + 1];
  }
  const nameIndex = args.indexOf('--tenant-name');
  if (nameIndex !== -1 && args[nameIndex + 1]) {
    options.tenantName = args[nameIndex + 1];
  }

  try {
    // Step 1: Install dependencies
    await installDependencies();

    // Step 2: Setup environment files
    if (!options.skipEnv) {
      await setupEnvFiles();
    }

    // Step 3: Start Docker services
    if (!options.skipDocker) {
      await startDockerServices();
      await waitForPostgres();
      await waitForRedis();
    }

    // Step 4: Run migrations
    await runMigrations();

    // Step 5: Provision default tenant
    if (!options.skipTenant) {
      await provisionDefaultTenant(options.tenantSlug!, options.tenantName!);
    }

    // Step 6: Seed test user
    await seedTestUser();

    // Print summary
    await printSummary();

  } catch (error) {
    log(`Setup failed: ${error}`, 'error');
    process.exit(1);
  }
}

main();
